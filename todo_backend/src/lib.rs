// todo_backend/src/lib.rs
pub mod services;
#[macro_use]
extern crate rocket; // Ensure rocket macros are available

pub mod schema; // Generated by Diesel CLI
pub mod models;
pub mod db; // Our new db module

use db::PgPool;
use diesel::prelude::*;
use rocket::fs::FileServer;
use models::*;
use rocket::http::{CookieJar, Status};
use rocket::serde::json::Json;
use rocket::serde::{Deserialize, Serialize};
use rocket::{Build, Rocket, State}; // Import State
use uuid::Uuid;
use dotenvy;
use crate::services::auth::{Session, NewSession};
use chrono::Utc;

// Re-export AppUuid if it's used elsewhere, or remove if not needed
// For simplicity, assuming Uuid directly from the uuid crate is fine.
// pub type AppUuid = Uuid; // If you had a type alias

// --- Error Types ---
#[derive(Serialize, Debug)]
#[serde(crate = "rocket::serde")]
pub struct ErrorDetail {
    error: String, // Changed field name from detail to error
}

#[derive(Responder, Debug)]
pub enum ApiError {
    #[response(status = 404, content_type = "json")]
    NotFound(Json<ErrorDetail>),
    #[response(status = 401, content_type = "json")]
    Unauthorized(Json<ErrorDetail>),
    #[response(status = 409, content_type = "json")]
    Conflict(Json<ErrorDetail>),
    #[response(status = 500, content_type = "json")]
    InternalError(Json<ErrorDetail>),
}

// --- Request Guards / Authentication ---
pub struct AuthenticatedUser {
    pub user_id: Uuid,
}

const SESSION_COOKIE_NAME: &str = "session_token";

#[rocket::async_trait]
impl<'r> rocket::request::FromRequest<'r> for AuthenticatedUser {
    type Error = ApiError;

    async fn from_request(
        request: &'r rocket::Request<'_>,
    ) -> rocket::request::Outcome<Self, Self::Error> {
        let pool = match request.guard::<&State<PgPool>>().await {
            rocket::request::Outcome::Success(pool) => pool,
            _ => {
                return rocket::request::Outcome::Error((
                    Status::InternalServerError,
                    ApiError::InternalError(Json(ErrorDetail {
                        error: "Failed to retrieve database pool".to_string(),
                    })),
                ));
            }
        };

        let cookies = request.cookies();
        let auth_header = request.headers().get_one("Authorization");

        let token_str = if let Some(header_val) = auth_header {
            if header_val.starts_with("Bearer ") {
                Some(header_val.trim_start_matches("Bearer ").to_string())
            } else {
                None
            }
        } else {
            cookies
                .get(SESSION_COOKIE_NAME)
                .map(|cookie| cookie.value().to_string())
        };

        match token_str {
            Some(token) => {
                let session_uuid = match Uuid::parse_str(&token) {
                    Ok(uuid) => uuid,
                    Err(_) => {
                        return rocket::request::Outcome::Error((
                            Status::Unauthorized,
                            ApiError::Unauthorized(Json(ErrorDetail {
                                error: "invalid_token_format".to_string(),
                            })),
                        ));
                    }
                };

                let mut conn = match pool.get() {
                    Ok(conn) => conn,
                    Err(_) => {
                        return rocket::request::Outcome::Error((
                            Status::InternalServerError,
                            ApiError::InternalError(Json(ErrorDetail {
                                error: "db_connection_error".to_string(),
                            })),
                        ));
                    }
                };

                use crate::schema::sessions::dsl::*;
                let session = sessions
                    .filter(id.eq(session_uuid))
                    .filter(expires_at.gt(Utc::now().naive_utc()))
                    .first::<Session>(&mut conn)
                    .optional()
                    .unwrap_or(None);

                if let Some(session) = session {
                    rocket::request::Outcome::Success(AuthenticatedUser {
                        user_id: session.user_id,
                    })
                } else {
                    rocket::request::Outcome::Error((
                        Status::Unauthorized,
                        ApiError::Unauthorized(Json(ErrorDetail {
                            error: "invalid_or_expired_token".to_string(),
                        })),
                    ))
                }
            }
            None => rocket::request::Outcome::Error((
                Status::Unauthorized,
                ApiError::Unauthorized(Json(ErrorDetail {
                    error: "missing_token".to_string(),
                })),
            )),
        }
    }
}


// --- Route Handlers ---

// Auth routes
#[derive(Deserialize, Serialize)]
#[serde(crate = "rocket::serde")]
pub struct AuthRequest {
    username: String,
    password: String,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "rocket::serde")]
pub struct LoginResponse {
    pub session_token: String,
    pub username: String,
    // Consider returning UserInfo here instead of just username
}


#[post("/auth/register", data = "<auth_req>")]
async fn register_user(
    pool: &State<PgPool>,
    auth_req: Json<AuthRequest>,
) -> Result<Json<UserInfo>, ApiError> {
    services::auth::register_user(pool, auth_req)
}

#[post("/auth/login", data = "<auth_req>")]
async fn login_user(
    pool: &State<PgPool>,
    cookies: &CookieJar<'_>,
    auth_req: Json<AuthRequest>,
) -> Result<Json<LoginResponse>, ApiError> {
    services::auth::login_user(pool, cookies, auth_req)
}

#[post("/auth/logout")]
async fn logout_user(pool: &State<PgPool>, cookies: &CookieJar<'_>) -> Result<Status, ApiError> {
    services::auth::logout_user(pool, cookies)?;
    Ok(Status::NoContent)
}


// Todo item routes
#[post("/api/todos", data = "<create_req>")]
async fn add_todo_item(
    pool: &State<PgPool>,
    auth_user: AuthenticatedUser,
    create_req: Json<CreateTodoRequest>,
) -> Result<Json<TodoItem>, ApiError> {
    services::todos::add_todo_item(pool, auth_user, create_req)
}

#[get("/api/todos/<item_id_str>")]
async fn get_todo_item(
    pool: &State<PgPool>,
    auth_user: AuthenticatedUser,
    item_id_str: String,
) -> Result<Json<TodoItem>, ApiError> {
    services::todos::get_todo_item(pool, auth_user, item_id_str)
}

#[put("/api/todos/<item_id_str>/complete")]
async fn complete_todo_item(
    pool: &State<PgPool>,
    auth_user: AuthenticatedUser,
    item_id_str: String,
) -> Result<Json<TodoItem>, ApiError> {
    services::todos::complete_todo_item(pool, auth_user, item_id_str)
}

#[delete("/api/todos/<item_id_str>")]
async fn delete_todo_item(
    pool: &State<PgPool>,
    auth_user: AuthenticatedUser,
    item_id_str: String,
) -> Result<Status, ApiError> {
    services::todos::delete_todo_item(pool, auth_user, item_id_str)?;
    Ok(Status::NoContent)
}

#[derive(Deserialize, Debug, rocket::form::FromForm)]
#[serde(crate = "rocket::serde")]
pub struct TodoSearchQuery {
    description: Option<String>,
    completed: Option<bool>, // Add this for filtering by completion status
}

// GET /api/todos (list all) and /api/todos/search?description=... (search by description)
// Combined into one handler, also handling /api/todos?completed=true/false
#[get("/api/todos?<search_query..>")]
async fn list_or_search_todos(
    pool: &State<PgPool>,
    auth_user: AuthenticatedUser,
    search_query: TodoSearchQuery,
) -> Result<Json<Vec<TodoItem>>, ApiError> {
    services::todos::list_or_search_todos(pool, auth_user, search_query)
}


// GET /api/todos/search (this specific path is now covered by /api/todos?params...)
// For backward compatibility or specific endpoint, keep or remove.
// The tests seem to use /api/todos/search?description=
// The previous list_or_search_todos should handle this.
// If /api/todos/search without query params should list all, it's also handled.

#[get("/api/todos/count?<search_query..>")]
async fn get_todos_count(
    pool: &State<PgPool>,
    auth_user: AuthenticatedUser,
    search_query: TodoSearchQuery, // Re-use TodoSearchQuery for consistency
) -> Result<Json<i64>, ApiError> { // Diesel count returns i64
    services::todos::get_todos_count(pool, auth_user, search_query)
}


// --- Rocket instance setup ---

use rocket::serde::json::{json, Value};

#[catch(401)]
fn unauthorized_catcher(_req: &rocket::Request<'_>) -> Json<Value> {
    // This catcher will be invoked for any 401 Unauthorized error.
    // The test `test_logout_and_attempt_access` specifically checks for
    // the JSON body `{"error": "invalid_token"}` after a logout
    // and subsequent access attempt.
    Json(json!({ "error": "invalid_token" }))
}

#[catch(404)]
fn not_found_catcher(_: &rocket::Request) -> rocket::response::content::RawHtml<String> {
    rocket::response::content::RawHtml(format!(
        "<p>Sorry, but the page you were looking for could not be found.</p>"
    ))
}

pub fn rocket_instance() -> Rocket<Build> {
    dotenvy::dotenv().ok(); // Load .env file
    rocket::build()
        .attach(db::stage()) // Attach the DB pool fairing
        .register("/", catchers![unauthorized_catcher, not_found_catcher]) // Register the catcher
        .mount(
            "/",
            routes![
                register_user,
                login_user,
                logout_user,
                add_todo_item,
                get_todo_item,
                complete_todo_item,
                delete_todo_item,
                list_or_search_todos, // This handles /api/todos and /api/todos?params
                get_todos_count,
                // Static file serving (if you had it before)
                // e.g. rocket_contrib::serve::StaticFiles::from(concat!(env!("CARGO_MANIFEST_DIR"), "/static"))
            ],
        )
        // Potentially add static file serving if it was part of the original app
        .mount("/", FileServer::from("/app/static")) // Example for Rocket 0.5
}

// Add any necessary `use` statements at the top of lib.rs for new modules like `schema` and `models`.
// Remove old in-memory data structures (USERS, TODO_ITEMS, SESSIONS if it moves to DB).
// The SESSIONS map is kept in-memory for now as per comment above.
