name: Rust CI with Docker

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  NETWORK_NAME: todo-network

jobs:
  build_and_test_dockerized:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker
      run: |
        docker --version
        docker compose version

    - name: Create custom Docker network
      run: docker network create $NETWORK_NAME

    - name: Build builder image
      run: docker build --target builder -t todo-builder -f todo_backend/Dockerfile .

    - name: Start db service
      # We only need the db service for the test phase.
      # It will be connected to the custom network so the test container can reach it.
      run: |
        docker compose up -d db
        docker network connect $NETWORK_NAME $(docker compose ps -q db)

    - name: Wait for db service to be healthy
      run: |
        echo "Waiting for db service to become healthy..."
        TIMEOUT=120 # 2 minutes timeout
        INTERVAL=5 # Check every 5 seconds
        ELAPSED=0
        while true; do
          DB_STATUS=$(docker compose ps db | grep 'healthy' | wc -l || true)

          if [ "$DB_STATUS" -ge 1 ]; then
            echo "Database service is healthy."
            break
          fi

          if [ "$ELAPSED" -ge "$TIMEOUT" ]; then
            echo "Timeout waiting for db service to become healthy."
            echo "--- DB Logs ---"
            docker compose logs db
            exit 1
          fi
          sleep $INTERVAL
          ELAPSED=$(($ELAPSED + $INTERVAL))
          echo "Still waiting for db... ($ELAPSED/$TIMEOUT seconds)"
        done

    - name: Run tests in builder container
      run: |
        echo "Running tests..."
        # Mount the current directory to /usr/src/app in the container
        # The builder Dockerfile has WORKDIR /usr/src/app
        # DATABASE_URL uses 'db' as hostname, which resolves on the custom network
        docker run --rm --network $NETWORK_NAME \
          -v $(pwd):/usr/src/app \
          -e DATABASE_URL="postgres://myuser:mypassword@db:5432/todo_db" \
          -e RUST_LOG=debug \
          -w /usr/src/app/todo_backend \
          todo-builder \
          cargo test -- --test-threads=1

    - name: Build and start app service
      run: |
        echo "Building and starting app service..."
        # Now build and start the 'app' service, which might depend on 'db'
        # The 'app' service will connect to the default docker-compose network,
        # or we could also connect it to $NETWORK_NAME if needed,
        # but its docker-compose.yml already defines how it connects to 'db'.
        docker compose up -d --build app

    - name: Wait for app service to be healthy
      # This is a new step to ensure the final app is healthy before finishing.
      run: |
        echo "Waiting for app service to become healthy..."
        TIMEOUT=120 # 2 minutes timeout
        INTERVAL=5 # Check every 5 seconds
        ELAPSED=0
        while true; do
          APP_STATUS=$(docker compose ps app | grep 'healthy' | wc -l || true)

          if [ "$APP_STATUS" -ge 1 ]; then
            echo "Application service is healthy."
            break
          fi

          if [ "$ELAPSED" -ge "$TIMEOUT" ]; then
            echo "Timeout waiting for app service to become healthy."
            echo "--- App Logs ---"
            docker compose logs app
            exit 1
          fi
          sleep $INTERVAL
          ELAPSED=$(($ELAPSED + $INTERVAL))
          echo "Still waiting for app... ($ELAPSED/$TIMEOUT seconds)"
        done

    - name: Stop services and remove network
      if: always() # Ensure cleanup happens even if previous steps fail
      run: |
        docker compose down -v
        docker network rm $NETWORK_NAME || true # Allow failure if network was already removed or never created
